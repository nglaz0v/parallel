# многопроцессность и многопоточность vs асинхронный ввод-вывод (*Python*)

**Параллельность (*Parallelism*)** - выполнение множества операций в одно и то же время.

**Многопроцессность (*Multiprocessing*)** чаще всего относится к эффекту параллельности и означает распределение задач между частями центральной вычислительной системы (процессорами или ядрами). Многопроцессность хорошо себя показали при задачах связанных с циклами for и математическими вычислениями.

**Одновременность (*Concurrency*)** - это чуть более широкий термин, чем параллельность. Он допускает, что задачи могут выполняться перекрывая друг друга. (это говорит что одновременность не всегда равна параллельности)

**Многопоточность (*Threading*)** - это модель, при которой задача разбивается на множество потоков, занимающихся её решением. Один процесс может содержать множество потоков. Самое важное, что стоит знать о многопоточности — она прекрасно решает задачи связанные с вводом/выводом (I/O) информации. Если задачи, привязанные к расчётам задействуют процессоры на протяжении всего периода решения, то задачи ввода/вывода допускают большие периоды ожиданий.

Чтобы немного подытожить, одновременность включает в себя и многопроцессность (идеальна для задач, требующих многих расчётов) и многопоточность (подходит для задач ввода/вывода). Многопроцессность это форма параллельности, которая является особым типом одновременности. Стандартные библиотеки Python достаточно давно могут поддерживать оба формата с помощью пакетов `multiprocessing` (process-based parallelism), `threading` (thread-based parallelism) и `concurrent.futures` (launching parallel tasks).

Пакет Python `asyncio` (**асинхронный ввод-вывод - *asynchronous I/O***) используется для написания кода, поддерживающего одновременное выполнение задач с использованием синтаксиса `async/await`. Однако она не использует ни мультипроцессность, ни многопоточность. Асинхронный ввод-вывод построен вокруг одного потока и одного процесса: он использует кооперативную многозадачность (*cooperative multitasking*). Другими словами, асинхронность позволяет создать впечатление многопоточности, несмотря на только 1 поток и процесс. Сопрограммы (*coroutines*) (главная особенность асинхронности - специализированная функция-генератор) могут находиться в графике одновременно, но не исполняться.

Чтобы закрепить, асинхронность близка к понятию одновременность, но не использует параллельность. Она ближе к многопоточности, чем к многопроцессности, но имеет так же и множество отличий от этих подходов, заслуживая отдельное место в череде терминов.

Это заставляет нас задуматься, что значит быть асинхронным? Для наших целей наиболее важны два свойства:
- асинхронные подпрограммы способны вставать на паузу, ожидая получение какого-то результата и давая работать другим подпрограммам
- учитывая сказанное выше, асинхронный код позволяет выполнять задачи одновременно. Если быть точным, то он имитирует ощущение одновременности.

Асинхронность удобна в случаях, когда есть большие «периоды ожидания», которые бы блокировали исполнение программы в случае стандартного исполнения кода.

| Concurrency Type | Switching Decision | Number of Processors |
|---|---|:---:|
| Pre-emptive multitasking (`threading`) | The operating system decides when to switch tasks external to Python. | 1 |
| Cooperative multitasking (`asyncio`) | The tasks decide when to give up control. | 1 |
| Multiprocessing (`multiprocessing`) | The processes all run at the same time on different processors. | Many |

**Используйте потоки для одновременного ввода-вывода и процессы для параллельных вычислений.**

## CPU-bound- и IO-bound-операции

Потоки внутри процессов выполняют задачи двух основных видов. Если скорость выполнения задачи зависит от мощности процессора — это CPU-bound-операция. Вот несколько примеров:
- потоковое видео;
- рендеринг графики в играх;
- сложные математические вычисления;
- обучение ML-модели.

Когда скорость выполнения задачи зависит от какой-то подсистемы, задача называется IO-bound-операцией: на них влияет не процессор, а какие-то внешние ресурсы. Обычно говорят, что IO-bound-операции зависят от подсистемы ввода-вывода (Input-Output). Вот примеры:
- скорость запроса на сайт зависит от API сайта;
- скорость запроса в базу данных зависит от базы;
- скорость записи файла на USB зависит от USB.

Один процесс может включать чередующиеся потоки с разными задачами: сначала вычисления CPU, потом запрос в подсистему, после её ответа снова вычисления.

Асинхронный подход означает выполнение CPU-bound-операций одновременно с выполнением IO-bound-операций где-то на внешних ресурсах.

**Асинхронное программирование идеально подходит для программ с IO-bound-операциями.** Можно посылать любое количество запросов на внешние системы и переключаться на другие задачи, пока не получим ответ.

*Для CPU-bound-задач асинхронное программирование бесполезно.* Оно предполагает переключение между потоками, когда есть свободные ресурсы. А в CPU-bound-операции свободных ресурсов нет: компьютеру нужно сосредоточиться на одной операции и выполнить её как можно скорее.

**Для операций CPU-bound хорошо подходит многопоточность**: выполнение сложных операций одновременно в параллельных потоках. Но в Python такой подход применить невозможно, и вот почему.

Python устроен так, что в единицу времени может работать только один поток. Это свойство называется глобальной блокировкой интерпретатора, или GIL (Global Interpreter Lock).

GIL упрощает управление памятью. В Python для этого используется подсчёт ссылок: программа считает, сколько раз какой-то объект упоминается в коде. Пока объект нужен, под него выделено необходимое количество памяти. Когда все ссылки на объект закончились, выделенное под него место освобождается. А ещё, если запустить сразу несколько потоков, они могут обратиться к одному и тому же объекту и изменить его одновременно, но по-разному, в итоге управление памятью сломается.

В Python тоже есть многопоточность. Она реализована в библиотеках, которые написаны на языке C, но их можно подключить и использовать. Например, NumPy или SciPy.

Получается, что GIL делает код на Python однопоточным, но одновременно повышает эффективность однопоточных программ. Нельзя сказать однозначно, хорошо это или плохо, и возможность отключения GIL обсуждается уже много лет. Пока он есть, надо уметь с ним работать.

## When to Use Concurrency

The first step of this process is deciding if you *should* use a concurrency module. Concurrency always comes with extra complexity and can often result in bugs that are difficult to find.

Hold out on adding concurrency until you have a known performance issue and *then* determine which type of concurrency you need.

Once you’ve decided that you should optimize your program, figuring out if your program is CPU-bound or I/O-bound is a great next step. Remember that I/O-bound programs are those that spend most of their time waiting for something to happen while CPU-bound programs spend their time processing data or crunching numbers as fast as they can.

As you saw, CPU-bound problems only really gain from using `multiprocessing`. `threading` and `asyncio` did not help this type of problem at all.

For I/O-bound problems, there’s a general rule of thumb in the Python community: ***“Use `asyncio` when you can, `threading` when you must.”*** `asyncio` can provide the best speed up for this type of program, but sometimes you will require critical libraries that have not been ported to take advantage of `asyncio`. Remember that any task that doesn’t give up control to the event loop will block all of the other tasks.

---
[Async IO in Python: A Complete Walkthrough](https://realpython.com/async-io-python/)  
[Speed Up Your Python Program With Concurrency](https://realpython.com/python-concurrency/)  
